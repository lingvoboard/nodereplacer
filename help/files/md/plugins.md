# ИНСТРУКЦИЯ К СКРИПТУ nodereplacer.js

### Содержание инструкции:

* [Установка](install.md)
* [Общий раздел](index.md)
* [Замены](replacer.md)
* **Дополнительные плагины**
* [Раздел для программистов](javascript.md)


ДОПОЛНИТЕЛЬНЫЕ ПЛАГИНЫ

Этот раздел содержит инструкции для плагинов, которые скорее всего будут интересны немногим.

### Содержание раздела:

1. [retag](#1-retag)
2. [cut](#2-node-nodereplacerjs--cut-)
3. [dt](#3-dt)
4. [rec](#4-rec)
5. [im](#5-im)
6. [title](#6-title)
7. [sdu](#7-sdu)
8. [htmldump](#8-htmldump)
9. [db](#9-db)

###### 1) retag
```
НАЗНАЧЕНИЕ
Исправление неправильных сочетаний DSL тегов с помощью parse5.

ВАРИАНТЫ КОМАНДНОЙ СТРОКИ
1)node nodereplacer.js -retag input.txt output.txt
2)node nodereplacer.js -retag -gls input.txt output.txt
3)node nodereplacer.js -retag -e input.txt output.txt
4)node nodereplacer.js -retag -rt input.txt output.txt

1)Вариант с одним ключом предназначен для обработки DSL файлов.
2)Со вторым ключом -gls - для обработки файлов в формате GLS2. 
3)-e - для обработки любых HTML файлов. Файл читается целиком в оперативную память.
4)-rt - для обработки файлов с HTML-кодом в построчном режиме.


ПРИМЕР

До)
test
  [b]болд [i]болд-курсив [/b]курсив [u]курсив-подчёркивание [/i]подчёркивание[/u]

После)
test
  [b]болд [i]болд-курсив [/i][/b][i]курсив [u]курсив-подчёркивание [/u][/i][u]подчёркивание[/u]

Внимание!
Обработка GLS статей с ключом -gls удаляет из них <head></head>, <html></html>, <body></body>.
А символы &<>, если они не являются частью тегов и HTML-сущностей, кодируются в &amp;&lt;&gt;
```
CREDITS</br>
[vsemozhetbyt](https://gist.github.com/vsemozhetbyt)</br>
Для написания плагина использовался [retag_misnested_dsl.js](https://gist.github.com/vsemozhetbyt/99132f861d8ab9505d7a9c1988e7b544)

###### 2) node nodereplacer.js -cut ...
```      
НАЗЕАЧЕНИЕ
Плагин предназначен для экстракции из входного файла фрагментов или разделение его на несколько частей.

ВАРИАНТЫ КОМАНДНОЙ СТРОКИ
rep -cut -t10 input.txt out.txt
rep -cut -d10 input.dsl out.dsl
rep -cut -g10 input.gls out.gls

rep -cut -t10% input.txt out.txt
rep -cut -d10% input.dsl out.dsl
rep -cut -g10% input.gls out.gls

rep -cut -b1000000 input.txt out.txt
rep -cut -b5000000 input.gls out.gls
...

rep -cut -t10%,20% input.txt out.txt.part1
rep -cut -d50%,50% input.dsl out.dsl.part1
rep -cut -g10%,20%,30% input.gls out.gls.part1

rep -cut -g20%,20%,20%,20% test.gls out.part1

rep -cut -t10%5 input.txt out.txt.part1
rep -cut -d10%5 input.dsl out.dsl.part1
rep -cut -g10%5 input.gls out.gls.part1

ПОЯСНЕНИЕ
-t10 - записать в выходной файл 10 строк из входного файла.
-d10 - записать в выходной файл 10 DSL статей из входного файла.
-g10 - записать в выходной файл 10 GLS статей из входного файла.

-b1000000 - записать в выходной файл примерно 1000000 байт из входного файла.
Примерно - поэтому, что скорее всего будет записано немно больше или меньше чем указано.
Ибо файл в этом режиме читается построчно и строки пишутся полностью,
а, к примеру, 1000000-ый байт может находится где-нибудь в середине строки.

-t10%, -d10%, -g10% - записать в выходной файл 10 процентов строк или статей из входного файла.

-t10%,20%, -d50%,50%... - записать в один выходной файл 10%, а во второй 20% строк или статей.

ВНИМАНИЕ!
В сумме части не должны превышать 100% 
Пример невалидного параметра: -d50%,50%,10% (Ибо 50% + 50% + 10% = 110%)

Сокращённый формат:
-t10%5 = -t10%,10%,10%,10%,10%
-d10%5 = -d10%,10%,10%,10%,10%
-g10%5 = -g10%,10%,10%,10%,10%

После % можно использовать число от 2 до 10.

Недопустимые значения: -t10%1, -t10%11 и т. п.

ПРИМЕР

До)

dog
translation

dog
translation

dog
translation

... и ещё 16 GLS статей.

Команда:
rep -cut -g20%4 test.gls out.part1

На выходе:
out.part1
out.part2
out.part3
out.part4

В каждом файле по 3 статьи.

Потому что Math.floor((20 / 100) * 16) = 3.

Команда:
rep -cut -g20%5 test.gls out.part1

На выходе:
out.part1
out.part2
out.part3
out.part4
out.part5

В 4 файлах по 3 статьи, в 5-том 4.

Потому что 3+3+3+3+4 = 16.
```
###### 3) dt
```
НАЗНАЧЕНИЕ
Получение списка DSL тэгов.

КОМАНДНАЯ СТРОКА
node nodereplacer.js -dt input.txt output.txt

Входной файл должен иметь словарную структуру (DSL). 

ПРИМЕР

После)

//ТЕГИ В КАРТОЧКАХ:

[/b]
[b]
[/c]
[c]
[/i]
[i]
[/lang]
[lang id=20]
[lang name="Russian"]
[/m]
[m1]
[/p]
[p]
[/ref]
[ref]
[/trn]
[trn]


//Теги с ошибками:
[c xxx] - Неизвестное имя цвета.
[lang id=000] - Неподдерживаемый идентификатор языка
[lang name="XXXX"] - Неподдерживаемый язык.
[lang name=Russian] - Имя языка без кавычек.
[lang] - Отсутствие значения у атрибута тега [lang].
[ref dict="Dicti"onary"] - Значение параметра dict содержит недопустимый символ.
[ref dict="Словарь"] - Имя словаря содержит символы, не входящие в набор ASCII.
[ref dict=Dictionary] - Значение параметра dict должно быть заключено в кавычки.


//ТЕГИ В ЗАГОЛОВКАХ:

[/b]
[b]
[/i]
[i]
{[/i]}
{[i]}
[/sub]
[sub]
{[/sub]}
{[sub]}


//Теги с ошибками:
[lang name=Russian] - Имя языка без кавычек.
```
###### 4) rec
```
НАЗНАЧЕНИЕ
Предназначен для рекурсивного слияния HTML-файлов находящихся в указанной папке.
Страницы пишутся одной строкой в выходной файл.

ВАРИАНТЫ КОМАНДНОЙ СТРОКИ
rep -recc "C:\Temp\Site" output
В качестве парсера используется модуль cheerio*.

rep -rec2 "C:\Temp\Site" output
В качестве парсера используется модуль sanitize-html (htmlparser2*).

rep -rec5 "C:\Temp\Site" output
В качестве парсера используется модуль parse5*.

--------------------

Пояснение:

* Различные парсеры могут работать по-разному,
  как в плане скорости, так и конечного результата.
* Наиболее строгим в плане следования стандартам является parse5.
  Но он же и самый медленный.
* Модули cheerio (текущая версия) и sanitize-html используют htmlparser2.
  Он работает быстрее, чем parse5 и отлично справляется с валидным HTML.
  С плохим, НЕвалидным кодом надёжнее использовать parse5.
* cheerio предоставляет широчайшие возможности по манипулированию
  элементами DOM, используя синтаксис JQuery. Смотрите документацию на
  https://github.com/cheeriojs/cheerio
* sanitize-html тоже предлагает функционал по "очистке" HTML-исходника.
  Документация - 
  https://github.com/punkave/sanitize-html
```
###### 5) im
```
НАЗНАЧЕНИЕ
Импорт морфологии в GLS файлы.

КОМАНДНАЯ СТРОКА
node nodereplacer.js -im morpholist.txt input.gls output.gls

Входные файлы (morpholist.txt и input.gls) должны иметь кодировку UTF-8.
input.gls должен быть в формате GLS2. 

morpholist.txt - должен содержать данные в таком формате:
словоформа[табулятор]начальная форма
словоформа[табулятор]начальная форма
кошками	кошка
коты	кошка
котами	кошка
кошаки	кошка

Пример:

Имеется morpholist.txt с таким содержанием:
кошками	кошка
коты	кошка
котами	кошка
кошаки	кошка
псина	собака
кошаки	кошка

ДО)

### Glossary title: Имя словаря
### Author: Имя автора
### Description: описание
### Source language: Russian
### Target language: Russian
### Glossary section:

кошка|кошка|кот
перевод

собака
перевод 

ПОСЛЕ)

### Glossary title: Имя словаря
### Author: Имя автора
### Description: описание
### Source language: Russian
### Target language: Russian
### Glossary section:

кошка|кот|кошками|коты|котами|кошаки
перевод

собака|псина
перевод

--------------------

Пояснение к примеру:

* Дубликаты из списка заголовков удаляются.
  При этом сохраняются заголовки, которые находятся в начале строки.
  Пример: до) кот|котами|кот => после) кот|котами (а не котами|кот)
* Если статья из input.gls содержит список заголовков,
  то для импорта используется только первый заголовок.
  Скрипт считает этот заголовок основным, который является начальной формой слова.
  Импорт будет произведен только если в morpholist.txt содержит запись
  у которой правая часть совпадает с ПЕРВЫМ заголовком некой статьи в input.gls

  А например при таком варианте импорта не произойдёт:

  morpholist.txt)
  кот  кошка

  input.gls)
  кот|кошка
  перевод

  Нужно "кошка|кот"
```
###### 6) title
```
НАЗНАЧЕНИЕ
Перенос данных из файла аббревиатур в HTML теги.

КОМАНДНАЯ СТРОКА
node nodereplacer.js -title input_abrv.dsl input.txt output.txt

Файл аббревиатур читается постатейно и следовательно должен иметь словарную структуру.
input.txt - построчно.

ПРИМЕР

___ input_abrv.dsl ___ 

#CONTENTS_LANGUAGE "French"
#INDEX_LANGUAGE "French"
#NAME "Le Nouveau Littré. 2008"
Ⓜ
      mot ajouté dans l'édition 2005 ou 2006
◆
      sens ajouté dans l'édition 2005 ou 2006
n. m.
      nom masculin

___ input.txt ___ 

ABACA <abbr>Ⓜ</abbr> <abbr>n. m.</abbr> <abbr>◆</abbr>

___ output.txt ___ 

ABACA <abbr title="mot ajouté dans l'édition 2005 ou 2006">Ⓜ</abbr> <abbr title="nom masculin">n. m.</abbr> <abbr title="sens ajouté dans l'édition 2005 ou 2006">◆</abbr>
```
###### 7) sdu
```
НАЗНАЧЕНИЕ
Извлечение из словарей в формате StarDict некоторой информации с использованием модуля stardictUtils.js

ВАРИАНТЫ КОМАНДНОЙ СТРОКИ
1)rep -sdu -tab1 input.idx output.txt
2)rep -sdu -tab2 input.dict.dz output.txt
3)rep -sdu -tab3 input.dsl output.txt
4)rep -sdu -tab4 input.dsl output.txt
5)rep -sdu -test=input.dz input_tab.txt output.txt

sdu - сокращение от StarDict Utils

Внимание!!!
Все входные файлы (словари и таблицы) должны быть в кодировке UTF-8

1)Первый вариант командной строки предназначен для получения информации типа:
lenire	4908797	122
lenendo	4908797	122
lenendola	4908797	122

Эта информация необходима при использовании функций getArticleBodyfromDZ1
и getArticleBodyfromDict модуля stardictUtils.js

Наличия .syn-файла в одной папке с input.idx - опционально, но если он имеется,
то он будет использован плагином в этом режиме.

2)Второй вариант командной строки  предназначен для получения информации типа:
lenire	[[1429391,1447508],[[0,18117]],[10337,10459]]
lenendo	[[1429391,1447508],[[0,18117]],[10337,10459]]
lenendola	[[1429391,1447508],[[0,18117]],[10337,10459]]

Эта информация необходима при использовании функции getArticleBodyfromDZ2 модуля stardictUtils.js

3)То же самое, что и первый вариант, но только не для словарей в формате StarDict, а для DSL-файлов.

4)То же самое, что и второй вариант, но для DSL-файлов.

Внимание!!!
Для этой операции необходим DZ-файл DSL-файла имя которого есть возможность указать в командной строке.
DZ-файл должен находиться в одной папке с DSL-файлом.
Его имя плагин вычисляет путём прибавления '.dz' к имени DSL-файла.
Пример: input.dsl и input.dsl.dz


5)Этот вариант предназначен для тестирования.
input_tab.txt - таблица, которая создаётся 4-ой командой (lenendo	[[1429391,1447508],[[0,18117]],[10337,10459]]).
На выходе, после распаковки DZ-файла,
должен получиться DSL-файл идентичный (с учётом отсутствия DSL-шапки) входному файлу,
который использовался для четвёртой операции (input.dsl). 
```

###### 8) htmldump
```
НАЗНАЧЕНИЕ

Обработка файла, который содержит результат объединения веб-страниц
Задача обработки - сделать так, чтобы \n остался только между страницам.

ПРИМЕР

До)

<html>
<head>
<title></title>
</head>
<body>dog</body>
</html>

<html>
<head>
<title></title>
</head>
<body>cat</body>
</html>

После)

<html><head><title></title></head><body>dog</body></html>
<html><head><title></title></head><body>cat</body></html>


ПРИМЕРЫ КОМАНД

node nodereplacer.js -htmldump '</script>' input.txt output.txt
node nodereplacer.js -htmldump '</html>' input.txt output.txt
node nodereplacer.js -htmldump '<\/html>' input.txt output.txt
node nodereplacer.js -htmldump '<\/html\s*>' input.txt output.txt

Второй аргумент - разделитель - регулярное выражение, которое описывает окончание каждой веб-страницы.
```

###### 9) db
```
НАЗНАЧЕНИЕ
Удаление дубликатов статей из очень больших DSL словарей (около гигабайта и больше).

КОМАНДНАЯ СТРОКА
node nodereplacer.js -rd db.js input.txt output.txt

Штатный плагин "d" делает то же самое, но если файл очень большой, то ему может не хватить памяти или операция будет длиться очень долго.

```

<hr>
