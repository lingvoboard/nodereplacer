<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="files/main.css" />
  <title>ИНСТРУКЦИЯ</title>
</head>
<body>
  <div class="c1">
    <h1>ИНСТРУКЦИЯ К СКРИПТУ nodereplacer.js</h1>
  </div>

  <p>Содержание инструкции:

  <ul>
    <li><b>Общий раздел</b>
    </li>

    <li><a href="replacer.htm">Замены</a>
    </li>

    <li><a href="plugins.htm">Дополнительные плагины</a>
    </li>

    <li><a href="javascript.htm">Раздел для программистов</a>
    </li>
  </ul>

  <div class="c1">
    ОБЩИЙ РАЗДЕЛ
  </div>

  <div class="Achtung c3">
    <br>
    Для запуска скрипта необходимо чтобы на вашем компьютере была установлена программная платформа <a class="c2" href="https://ru.wikipedia.org/wiki/Node.js">Node.js</a> версии желательно не ниже <b>8.8.1</b><br>
    Если не установлена, то берём <a class="c2" href="https://nodejs.org/">здесь</a>.
  </div>

  <div class="Achtung c3">
    <br>
    Список замен и входной файл должны иметь кодировку UTF8 (с BOM или без) или UTF16LE (обязательно с BOM).
  </div>

  <div class="Achtung c3">
    <br>
    Если <b>nodereplacer.js</b> прекращает работу с сообщением, которое содержит "<span class="c4">out of memory</span>", такое может произойти при обработке очень больших файлов (если обработка сопровождается чтением всего входного файла в оперативную память), то можно попробовать запуск скрипта с ключом <span class="c4">--max_old_space_size=4096</span><br>
    Отредактируйте для этого файл <b>rep.bat</b>, должно быть так:<br>
    node --max_old_space_size=4096 --harmony_regexp_lookbehind --harmony_regexp_property...<br>
    Значение ключа может быть и другим, в приведённом примере 4096 означает 4 гигабайта.
  </div>

  <p><span class="subs">Содержание раздела</span>:

  <p>&nbsp;&nbsp;<a href="#op1">1.</a> Замены в файле имеющем словарную структуру (DSL).<br>
  &nbsp;&nbsp;<a href="#op2">2.</a> Замены в файле не имеющем словарную структуру.<br>
  &nbsp;&nbsp;<a href="#op3">3.</a> Замены в файле в формате GLS.<br>
  &nbsp;&nbsp;<a href="#op4">4.</a> Замены между указанными DSL тегами.<br>
  &nbsp;&nbsp;<a href="#op5">5.</a> Конвертирование словарей формате в GLS в формат StarDict и обратно.<br>
  &nbsp;&nbsp;<a href="#op6">6.</a> Исправление ошибок форматирования в DSL файле.<br>
  &nbsp;&nbsp;<a href="#op7">7.</a> Удаление дубликатов статей (DSL).<br>
  &nbsp;&nbsp;<a href="#op8">8.</a> Объединение статей с одинаковыми заголовками (DSL).<br>
  &nbsp;&nbsp;<a href="#op9">9.</a> Складывание заголовков в стопы (DSL).<br>
  <a href="#op10">10.</a> Маркировка подвешенных ссылок (DSL).<br>
  <a href="#op11">11.</a> Получение списка всех символов.<br>
  <a href="#op12">12.</a> Сортировка (DSL).<br>
  <a href="#op13">13.</a> Пользовательская сортировка (DSL).<br>
  <a href="#op14">14.</a> Сортировка DSL тегов.<br>
  <a href="#op15">15.</a> Внедрение картинок в HTML файл.<br>
  <a href="#op16">16.</a> Раскрытие круглых скобок в заголовках словарных исходников.<br>
  <a href="#op17">17.</a> Получение списка HTML тегов.<br>
  <a href="#op18">18.</a> Выявление ошибок в словарях в формате DSL.<br>
  <a href="#op19">19.</a> Объединение статей в словарях в формате GLS.<br>
  <a href="#add">Дополнение</a>

  <p><span class="subs">Варианты командной строки</span>:

  <p>&nbsp;<a href="#op1">1.</a> node nodereplacer.js -rd list input.txt output.txt<br>
  &nbsp;<a href="#op2">2.</a> node nodereplacer.js (-rt|-re) list input.txt output.txt<br>
  &nbsp;<a href="#op3">3.</a> node nodereplacer.js -rg list input.txt output.txt<br>
  &nbsp;<a href="#op4">4.</a> node nodereplacer.js -rs list -[A-Za-z]{1,10} input.txt output.txt<br>
  &nbsp;<a href="#op5">5.</a> node nodereplacer.js (input.gls|input.ifo)<br>
  &nbsp;<a href="#op6">6.</a> node nodereplacer.js -ctags input.txt output.txt<br>
  &nbsp;<a href="#op7">7.</a> node nodereplacer.js -d input.txt output.txt<br>
  &nbsp;<a href="#op8">8.</a> node nodereplacer.js -m -(a|a1|a2|l|l1|l2|r|r1|r2) input.txt output.txt<br>
  &nbsp;<a href="#op9">9.</a> node nodereplacer.js -pile input.txt output.txt<br>
  <a href="#op10">10.</a> node nodereplacer.js -susp input.txt output.txt<br>
  <a href="#op11">11.</a> node nodereplacer.js (-symb|-symb -f) input.txt output.txt<br>
  <a href="#op12">12.</a> node nodereplacer.js -sort -(b|o|bi|bie|oi|oie|bd|od|bdc|odc) input.txt output.txt<br>
  <a href="#op13">13.</a> node nodereplacer.js (-usort|-usort -i) input.txt output.txt<br>
  <a href="#op14">14.</a> node nodereplacer.js -stags input.txt output.txt<br>
  <a href="#op15">15.</a> node nodereplacer.js (-base64 -i|-base64) input.txt output.txt<br>
  <a href="#op16">16.</a> node nodereplacer.js -rb -(dsl1|dsl2|dslm1|dslm2|gls|glsm) input.txt output.txt<br>
  <a href="#op17">17.</a> node nodereplacer.js -t input.txt output.txt<br>
  <a href="#op18">18.</a> node nodereplacer.js (-chkdsl|-chkdsl -t) input.txt output.txt<br>
  <a href="#op19">19.</a> node nodereplacer.js -mgls input.txt output.txt

  <p><span class="subs">Назначение и использование</span>:

  <p><span><a class="mark" href="#op1" id="op1" name="op1">#</a></span> 1) <span class="comline">node nodereplacer.js -rd list.txt input.txt output.txt</span><br>
  Замены в файле имеющем словарную структуру<a href="#dic"><sup>1</sup></a> используя список замен (<span class="comline">list.txt</span>).

  <p><span><a class="mark" href="#op2" id="op2" name="op2">#</a></span> 2) <span class="comline">node nodereplacer.js (-rt|-re) list.txt input.txt output.txt</span><br>
  Замены в файле <b>не</b> имеющем словарную структуру используя список замен (<span class="comline">list.txt</span>).<br>
  С ключом <span class="comline">-rt</span> входной файл читается и обрабатываться построчно.<br>
  С ключом <span class="comline">-re</span> (<span class="comline">r</span><i>ead</i> <span class="comline">e</span><i>ntire file</i>) данные из входного файла сначала полностью считываются в оперативную память компьютера и затем обрабатываются целиком, а не построчно или постатейно.

  <p><span><a class="mark" href="#op3" id="op3" name="op3">#</a></span> 3) <span class="comline">node nodereplacer.js -rg list.txt input.txt output.txt</span><br>
  Замены в файле в формате GLS<a href="#gls"><sup>2</sup></a> используя список замен (<span class="comline">list.txt</span>).

  <p><span><a class="mark" href="#op4" id="op4" name="op4">#</a></span> 4) <span class="comline">node nodereplacer.js -rs list.txt -[A-Za-z]{1,10} input.txt output.txt</span><br>
  Замены между указанными DSL тэгами.<br>
  Входной файл должен иметь словарную структуру.<br>
  Допустимые теги: [b], [i], [u], [c], [sup], [sub], [m], [p], [t], [ex], [com], [trn], [s], [video], [preview], [ref], [url]

  <p>Примеры командной строки:<br>
  [b] - <i>node nodereplacer.js -rs list.txt -b input.txt output.txt</i><br>
  [com] - <i>node nodereplacer.js -rs list.txt -com input.txt output.txt</i>

  <p><a href="replacer.htm">Подробности по заменам на отдельной странице</a>.

  <hr />

  <p><span><a class="mark" href="#op5" id="op5" name="op5">#</a></span> 5) <span class="comline">node nodereplacer.js (input.gls|output.ifo)</span><br>
  Конвертирование словарей формате GLS в формат StarDict и обратно.<br>
  Поддерживается только <a href="files/StarDictFileFormat.txt" target="_blank">sametypesequence=h</a>

  <p>Варианты командной строки:<br>
  node nodereplacer.js словарь.gls<br>
  node nodereplacer.js словарь.ifo

  <p>Направление конвертирования определяется расширением файла в единственном аргументе.

  <p><a href="http://linuxcommand.org/man_pages/dictzip1.html">DICTZIP</a><br>
  Если на Linux имеется dictzip (/usr/bin/dictzip), то после конвертирования (GLS-&gt;StarDict)<br>
  скрипт сожмёт созданный .dict файл используя эту утилиту.

  <p><a href="https://github.com/Tvangeste/dictzip-win32/releases">dictzip.exe</a> для Windows можно найти в архиве со скриптом.<br>
  Перенесите его папку C:\Windows\System32\

  <p>CREDITS: <a class="c2" href="https://gist.github.com/vsemozhetbyt">vsemozhetbyt</a><br>
  Для написания плагина использовался <a href="https://gist.github.com/vsemozhetbyt/2b92014cd65e8fb3c3e5c0897a750e40">gls_sd_conv.js</a> (версия после ревизии, которая была слелана <a href="https://gist.github.com/vsemozhetbyt/2b92014cd65e8fb3c3e5c0897a750e40/revisions">14.04.2017</a>)

  <p><span><a class="mark" href="#op6" id="op6" name="op6">#</a></span> 6) <span class="comline">node nodereplacer.js -ctags input.txt output.txt</span><br>
  Исправление некоторых ошибок форматирования словарей в формате DSL.<br>
  Входной файл должен иметь словарную структуру.

  <p>Пример:

  <p><i>До</i>)

  <pre>
заголовок
        [c yellow] [i] [i] [/i] [/i] [/p] [c red] [c blue] [/c] [/c] [/c] [/i] [u] [c red]
заголовок
        [c red] [c blue] [/c]
заголовок
        [/c] [c red] [c blue] [/c]
заголовок
        [i] [/i] [/i]
        [u] [i] [i] [u] [/u] [/i] [/i] [/u]
        [i] [i] [/i] [i] [/i] [/i]
        [c red] [/c] [/c]
        [c red] [c blue] [/c] [/c]
заголовок
        [lang id=2] [lang id=4] [/lang]
        [lang name="Russian"] [lang name="Russian"] [/lang]
        [lang name="Russian"] [lang id=10] [/lang]
        [lang name="Russian"] [lang name="Russian"] [/lang]
        [sup] [sup]
        [u] [u] [/u] [/u]
        ['] [/'] [/']
        [c] [c blue] [/c] [/c]
заголовок
        [c blue] dog [c red] pig [/c] [c] cat [/c] cow [/c] end
        [c blue] dog [c red] pig [/c] [c] cat [/c] cow end
        [c blue] dog [c red] pig [c] cat [/c] cow [/c] end
        [i] 1 [i] 2 [i] 3 [/i] 4 [/i] 5 [/i] end
        [i] 1 [i] 2 [i] 3 [/i] 4 [/i] 5 end
        [!trs] 1 [!trs] 2 [/!trs] 3 [/!trs] end
        [ex] 1 [ex] 2 [/ex] 3 [/ex] end
        [trn] 1 [trn] 2 [/trn] 3 [/trn] end
</pre>
  <p><i>После</i>)

  <pre>
заголовок
        [c yellow] [i] [/i][i] [/i][i] [/i] {{[/p]}} [/c][c red] [/c][c blue] [/c][c red] [/c][c yellow] [/c] {{[/i]}} {{[u]}} {{[c red]}}
заголовок
        {{[c red]}} [c blue] [/c]
заголовок
        {{[/c]}} {{[c red]}} [c blue] [/c]
заголовок
        [i] [/i] {{[/i]}}
        [u] [i] [/i][i] [/u][u] [/u][u] [/i][i] [/i] [/u]
        [i] [/i][i] [/i][i] [/i][i] [/i][i] [/i]
        [c red] [/c] {{[/c]}}
        [c red] [/c][c blue] [/c][c red] [/c]
заголовок
        {{[lang id=2]}} [lang id=4] [/lang]
        {{[lang name="Russian"]}} [lang name="Russian"] [/lang]
        {{[lang name="Russian"]}} [lang id=10] [/lang]
        {{[lang name="Russian"]}} [lang name="Russian"] [/lang]
        {{[sup]}} {{[sup]}}
        [u] [/u][u] [/u][u] [/u]
        ['] [/'] {{[/']}}
        [c] [/c][c blue] [/c][c] [/c]
заголовок
        [c blue] dog [/c][c red] pig [/c][c blue] [/c][c] cat [/c][c blue] cow [/c] end
        {{[c blue]}} dog [c red] pig [/c] [c] cat [/c] cow end
        {{[c blue]}} dog [c red] pig [/c][c] cat [/c][c red] cow [/c] end
        [i] 1 [/i][i] 2 [/i][i] 3 [/i][i] 4 [/i][i] 5 [/i] end
        {{[i]}} 1 [i] 2 [/i][i] 3 [/i][i] 4 [/i] 5 end
        [!trs] 1 [/trs][!trs] 2 [/!trs][!trs] 3 [/!trs] end
        [ex] 1 [/ex][ex] 2 [/ex][ex] 3 [/ex] end
        [trn] 1 [/trn][trn] 2 [/trn][trn] 3 [/trn] end
</pre>
  <p><span><a class="mark" href="#op7" id="op7" name="op7">#</a></span> 7) <span class="comline">node nodereplacer.js -d input.txt output.txt</span><br>
  Удаление из словаря дубликатов статей.<br>
  Входной файл должен иметь словарную структуру.

  <p>Пример:

  <p><i>До</i>)

  <pre>
dog
        собака
perro
        собака
dog
        собака
</pre>
  <p><i>После</i>)

  <pre>
dog
        собака
perro
        собака
</pre>
  <p>Закомментированные части в заголовках игнорируются, в теле - нет.

  <p>Пример:

  <p><i>До</i>)

  <pre>
dog
        собака
perro
        собака
dog{{комментарий}}
        собака
dog
        собака{{комментарий}}
</pre>
  <p><i>После</i>)

  <pre>
dog
        собака
perro
        собака
dog
        собака{{комментарий}}
</pre>
  <p><i>Удаленные дубликаты записываются в файл</i> <b>dub.txt</b>

  <p><i>Если входной файл содержит статьи с несколькими заголовками сложенными в стопы, то при обработке такие статьи будут разобраны</i>.

  <p>Пример:

  <p><i>До</i>)

  <pre>
dog
perro
        собака
</pre>
  <p><i>После</i>)

  <pre>
dog
        собака
perro
        собака
</pre>
  <p><span><a class="mark" href="#op8" id="op8" name="op8">#</a></span> 8) <span class="comline">node nodereplacer.js -m -(a|a1|a2|l|l1|l2|r|r1|r2) input.txt output.txt</span><br>
  Объединение в словаре разных статей с одинаковыми заголовками с предварительным удалением дубликатов статей.<br>
  Входной файл должен иметь словарную структуру.

  <p><b>-a</b> - <i>использовать в качестве разделителя <b>арабские</b> цифры.</i>

  <p><b>-l</b> - <i>использовать в качестве разделителя <b>линию</b>.</i>

  <p><b>-r</b> - <i>использовать в качестве разделителя <b>римские цифры</b>.</i>

  <p><b>-a1, -a2, -l1, -l2, -r1, -r2</b> - <i>обрабатывать заголовки с фигурными скобками (если перед ними нет обратного слэша).</i>

  <p><b>-a1, -l1, -r1</b> - <i>в качестве заголовка для объединенной карточки берется самый КОРОТКИЙ заголовок.</i>

  <p><b>-a2, -l2, -r2</b> - <i>в качестве заголовка для объединенной карточки берется самый ДЛИННЫЙ заголовок.</i>

  <p>Пример №1:

  <p>Командная строка:<br>
  <i>node nodereplacer.js -m <b>-l</b> input.txt output.txt</i>

  <p><i>До</i>)

  <pre>
собака
        dog
собака
        perro
dog
        собака
</pre>
  <p><i>После</i>)

  <pre>
собака
        dog
        ————————
        perro
dog
        собака
</pre>
  <p>Пример №2:

  <p>Командная строка:<br>
  <i>node nodereplacer.js -m <b>-l1</b> input.txt output.txt</i>

  <p><i>До</i>)

  <pre>
111 {333} 222 {444}
        pig
111 222
        dog
111 {333} 222
        dog
111 222  
        dog
</pre>
  <p><i>После</i>)

  <pre>
111 222
        pig
        ————————
        dog
</pre>
  <p>Пример №3:

  <p>Командная строка:<br>
  <i>node nodereplacer.js -m <b>-l2</b> input.txt output.txt</i>

  <p><i>До</i>)

  <pre>
111 {333} 222 {444}
        pig
111 222
        dog
111 {333} 222
        dog
111 222  
        dog
</pre>
  <p><i>После</i>)

  <pre>
111 {333} 222 {444}
        pig
        ————————
        dog
</pre>
  <p><i>Удаленные дубликаты записываются в файл</i> <b>dub.txt</b>

  <p><i>Если входной файл содержит статьи с несколькими заголовками сложенными в стопы, то при обработке такие статьи будут разобраны</i>.

  <p>Закомментированные части в заголовках игнорируются, в теле - нет.

  <p>Пример:

  <p><i>До</i>)

  <pre>
dog
        собака
dog{{комментарий}}
        собака
dog
        собака{{комментарий}}
</pre>
  <p><i>После</i>)

  <pre>
dog
        собака
        ————————
        собака{{комментарий}}
</pre>
  <p><span><a class="mark" href="#op9" id="op9" name="op9">#</a></span> 9) <span class="comline">node nodereplacer.js -pile input.txt output.txt</span><br>
  Объединение статей в словаре имеющих одинаковое тело со складыванием заголовков в стопы.<br>
  Входной файл должен иметь словарную структуру.

  <p>Пример:

  <p><i>До</i>)

  <pre>
perro
        собака
dog
        собака
cane
        собака
</pre>
  <p><i>После</i>)

  <pre>
perro
dog
cane
        собака
</pre>
  <p><span><a class="mark" href="#op10" id="op10" name="op10">#</a></span> 10) <span class="comline">node nodereplacer.js -susp input.txt output.txt</span><br>
  Маркировка подвешенных ссылок в DSL файле.<br>
  Входной файл должен иметь словарную структуру.

  <p>Пример:

  <p><i>До</i>)

  <pre>
perro
        &lt;&lt;собака&gt;&gt; [ref]cane[/ref] &lt;&lt;pies&gt;&gt; &lt;&lt;dog&gt;&gt;
dog
        собака
cane
        собака
</pre>
  <p><i>После</i>)

  <pre>
perro
        &lt;&lt;$$$собака$$$&gt;&gt; [ref]cane[/ref] &lt;&lt;$$$pies$$$&gt;&gt; &lt;&lt;dog&gt;&gt;
dog
        собака
cane
        собака
</pre>
  <p>Обратный слеш перед перед квадратными и круглыми скобками,<br>
  пробелы и табуляторы на конце заголовка скриптом игнорируются.<br>
  Т.е. к примеру, скрипт не будет маркировать ссылку &lt;&lt;dog[s]&gt;&gt; если имеется заголовок dog\[s\].

  <p>Круглые скобки в заголовках раскрываются, а {{текст}} и {текст} игнорируется.

  <p>Пример:

  <p><i>До</i>)

  <pre>
dog{1}
{{комментарий}}
c{{комментарий}}at
кошка(ми)
   перевод
test
   &lt;&lt;dog&gt;&gt;
   [ref]cat[/test]
   &lt;&lt;проверка&gt;&gt;
   &lt;&lt;{{комментарий}}&gt;&gt;
   &lt;&lt;кошка&gt;&gt;
   [ref]кошками[/ref]
   [ref]кошка(ми)[/ref]
</pre>
  <p><i>После</i>)

  <pre>
dog{1}
{{мусор}}
c{{мусор}}at
кошка(ми)
   перевод
test
   &lt;&lt;dog&gt;&gt;
   [ref]cat[/test]
   &lt;&lt;$$$проверка$$$&gt;&gt;
   &lt;&lt;$$${{мусор}}$$$&gt;&gt;
   &lt;&lt;кошка&gt;&gt;
   [ref]кошками[/ref]
   [ref]$$$кошка(ми)$$$[/ref]
</pre>
  <p><span><a class="mark" href="#op11" id="op11" name="op11">#</a></span> 11) <span class="comline">node nodereplacer.js (-symb|-symb -f) input.txt output.txt</span><br>
  Получение списка всех символов в текстовом файле и некоторой информации об этих символах.

  <p>При использовании ключа <span class="comline">-f</span> список сортируется по частотности.

  <p>Пример:

  <p><i>До</i>)

  <pre>
 b
 🐵😻💩
 ccc
 aa
</pre>
  <p><i>После</i> <span class="comline">-symb</span>)

  <p><span class="comment">node nodereplacer.js -symb input.txt output.txt</span>
  

  <pre>
        0020    32      SPACE   4
a       0061    97      LATIN SMALL LETTER A    2
b       0062    98      LATIN SMALL LETTER B    1
c       0063    99      LATIN SMALL LETTER C    3
🐵       1F435   128053  MONKEY FACE     1
💩       1F4A9   128169  PILE OF POO     1
😻       1F63B   128571  SMILING CAT FACE WITH HEART-SHAPED EYES 1
</pre>
  <p><i>После</i> <span class="comline">-symb -f</span>)

  <p><span class="comment">node nodereplacer.js -symb -f input.txt output.txt</span>
  

  <pre>
        0020    32      SPACE   4
c       0063    99      LATIN SMALL LETTER C    3
a       0061    97      LATIN SMALL LETTER A    2
b       0062    98      LATIN SMALL LETTER B    1
🐵       1F435   128053  MONKEY FACE     1
💩       1F4A9   128169  PILE OF POO     1
😻       1F63B   128571  SMILING CAT FACE WITH HEART-SHAPED EYES 1
</pre>
  <p><i>Последняя колонка - частотность. Вторая - шестнадцатеричное значение символа</i>
  

  <p><span><a class="mark" href="#op12" id="op12" name="op12">#</a></span> 12) <span class="comline">node nodereplacer.js -sort -(b|o|bi|bie|oi|oie|bd|od|bdc|odc) input.txt output.txt</span><br>
  Сортировка статей в DSL файле.

  <p>Внимание: Во всех режимах комментарии в заголовках игнорируются.

  <p><b>-b</b> - <i>сортировать статьи по заголовкам с учетом содержимого тела карточки.</i>

  <p>Пример:

  <p><i>До</i>)

  <pre>
pig
        свинья 2
horse
        лошадь
dog
        собака
pig
        свинья 1
</pre>
  <p><i>После</i>)

  <pre>
dog
        собака
horse
        лошадь
pig
        свинья 1
pig
        свинья 2
</pre>
  <p><b>-o</b> - <i>сортировать статьи по заголовкам, но с сохранением оригинального порядка в блоке статей имеющих одинаковый заголовок.</i>

  <p>Пример:

  <p><i>До</i>)

  <pre>
pig
        свинья 2
horse
        лошадь
dog
        собака
pig
        свинья 1
</pre>
  <p><i>После</i>)

  <pre>
dog
        собака
horse
        лошадь
pig
        свинья 2
pig
        свинья 1
</pre>
  <p class="c5"><b>-bi</b> - <i>сортировать статьи по заголовкам с учетом содержимого тела карточки.</i>

  <div class="c6">
    <i>И при сортировке игнорировать в заголовках:</i><br>
    а) <i>фигурные скобки и все, что находится между ними</i><br>
    б) <i>обратный слэш перед символами</i> @#^~[]{}()
  </div>

  <p>Пример:

  <p><i>До</i>)

  <pre>
pig
        свинья 2
horse
        лошадь
pig
        свинья 1
{[i]}d{[/i]}og
        собака
</pre>
  <p><i>После</i>)

  <pre>
{[i]}d{[/i]}og
        собака
horse
        лошадь
pig
        свинья 1
pig
        свинья 2
</pre><br>

  <p class="c5"><b>-bie</b> - <i>это расширенный вариант <b>-bi</b>.</i>

  <div class="c6">
    <i>При сортировке игнорируются также:</i><br>
    а) <i>символы</i>: «»"„“”‘’…<br>
    б) <i>многоточие из обычных точек (это помимо Horizontal ellipsis (U+2026))</i><br>
    в) <i>диакритические знаки в символах</i> ё и Ё.<br>
    г) <i>круглые скобки и все, что находится между ними</i>
  </div>
  <br>

  <p class="c5"><b>-oi</b> - <i>сортировать статьи по заголовкам, но с сохранением оригинального порядка в блоке статей имеющих одинаковый заголовок.</i>

  <div class="c6">
    <i>И при сортировке игнорировать в заголовках:</i><br>
    а) <i>фигурные скобки и все, что находится между ними</i><br>
    б) <i>обратный слэш перед символами</i> @#^~[]{}()
  </div>

  <p>Пример:

  <p><i>До</i>)

  <pre>
pig
        свинья 2
horse
        лошадь
pig
        свинья 1
{[i]}d{[/i]}og
        собака
</pre>
  <p><i>После</i>)

  <pre>
{[i]}d{[/i]}og
        собака
horse
        лошадь
pig
        свинья 2
pig
        свинья 1
</pre><br>

  <p class="c5"><b>-oie</b> - <i>это расширенный вариант <b>-oi</b>.</i>

  <div class="c6">
    <i>При сортировке игнорируются также:</i><br>
    а) <i>символы</i>: «»"„“”‘’…<br>
    б) <i>многоточие из обычных точек (это помимо Horizontal ellipsis (U+2026))</i><br>
    в) <i>диакритические знаки в символах</i> ё и Ё.<br>
    г) <i>круглые скобки и все, что находится между ними</i>
  </div>
  <br>

  <p><b>-bd</b> - <i>то же самое, что и <b>-b</b>, но с игнорированием диакритических знаков в заголовках</i><br>
  Входной файл должен иметь словарную структуру.

  <p>Пример:

  <p><i>До</i>)

  <pre>
z
        aaa
e
        aaa2
ø
        aaa
p
        aaa
å
        aaa
é
        aaa1
d
        aaa
</pre>
  <p><i>После</i>)

  <pre>
å
        aaa
d
        aaa
é
        aaa1
e
        aaa2
ø
        aaa
p
        aaa
z
        aaa
</pre>
  <p><b>-od</b> - <i>то же самое, что и <b>-o</b>, но с игнорированием диакритических знаков в заголовках</i><br>
  Входной файл должен иметь словарную структуру.

  <p>Пример:

  <p><i>До</i>)

  <pre>
z
        aaa
e
        aaa2
ø
        aaa
p
        aaa
å
        aaa
é
        aaa1
d
        aaa
</pre>
  <p><i>После</i>)

  <pre>
å
        aaa
d
        aaa
e
        aaa2
é
        aaa1
ø
        aaa
p
        aaa
z
        aaa
</pre>
  <p><b>-bdc</b> - <i>то же самое, что и <b>-bd</b>, но с игнорированием регистра</i><br>
  Входной файл должен иметь словарную структуру.

  <p>Пример:

  <p><i>До</i>)

  <pre>
mⱥlta 2
        aaa
Mḁlta 3
        aaa
MÀLTA 1
        aaa
</pre>
  <p><i>После</i>)

  <pre>
MÀLTA 1
        aaa
mⱥlta 2
        aaa
Mḁlta 3
        aaa
</pre>
  <p><b>-odc</b> - <i>то же самое, что и <b>-od</b>, но с игнорированием регистра</i><br>
  Входной файл должен иметь словарную структуру.

  <p><span><a class="mark" href="#op13" id="op13" name="op13">#</a></span> 13) <span class="comline">node nodereplacer.js (-usort|-usort -i) input.txt output.txt</span><br>
  Пользовательская сортировка.<br>
  Входной файл должен иметь словарную структуру (в формате DSL<a href="#dic"><sup>1</sup></a>).<br>
  Файл с правилами сортировки <span class="comline">sortRules.txt</span> должен лежать в одной папке со скриптом. Его наличие опционально.

  <p>Следующие символы скрипт из <span class="comline">sortRules.txt</span> удаляет:<br>
  \x20\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff

  <p>Статьи сортируются только по заголовкам и с сохранением оригинального порядка в блоке статей имеющих одинаковый заголовок. При сортировке тело статей не учитывается.

  <p><b>-i</b> - <i>Чтобы скрипт не выделял статьи с заголовками, которые начинаются на заглавные буквы в отдельные блоки (сортировать с игнорированием регистра).</i>

  <p>Пример (Обратная сортировка):

  <p>Командная строка:<br>
  <i>node nodereplacer.js <b>-usort -i</b> input.txt output.txt</i>

  <p>Содержание <span class="comline">sortRules.txt</span>:<br>
  zyxwvutsrqponmlkjihgfedcba

  <p><i>До</i>)

  <pre>
zebra
        перевод
dog
        перевод
pig
        перевод
</pre>
  <p><i>После</i>)

  <pre>
zebra
        перевод
pig
        перевод
dog
        перевод
</pre>
  <p>Чтобы статьи у которых заголовки начинаются с буквы с диакритическим знаком не оказывались после статей заголовки которых начинаются на последнюю букву алфавита можно использовать <span class="comline">sortRules.txt</span> с таким содержанием:

  <pre>aàâbcçdeéèêëfghiîïjklmnoôpqrstuùûüvwxyÿz</pre>
  <p>Для турецкого языка:

  <pre>AaBbCcÇçDdEeFfGgĞğHhIıİiJjKkLlMmNnOoÖöPpRrSsŞşTtUuÜüVvYyZz</pre>
  <p>Скрипт должен правильно работать с многобайтными символами Юникода:<br>
  <img src="files/multibyte.png" />

  <p><span><a class="mark" href="#op14" id="op14" name="op14">#</a></span> 14) <span class="comline">node nodereplacer.js -stags input.txt output.txt</span><br>
  Сортировка DSL тегов.<br>
  Входной файл должен иметь словарную структуру.

  <p>Скрипт сначала сортирует открывающие теги в зависимости от положения закрывающих тегов.<br>
  Потом сортирует закрывающие теги в зависимости от положения открывающих тегов.

  <p>Некоторые DSL теги скрипт игнорирует:<br>
  \[(?:(?:(?:br|[stm]|m\d|url|video|preview|ref)|ref\x20[^\r\n\]]+)|\/(?:[stm]|ref|url|video|preview))\]

  <p>Пример:

  <p><i>До</i>)

  <pre>
заголовок
        [m1][p][i][c][com]сокр.[/i][/p] от [ref]them[/ref]; [p][i]разг.[/com][/c][/i][/p][/m]  
        [m1][p][i][c][com]гл.[/i][/p]; [p][i]сокр.[/i][/p]; [p][i]разг.[/com][/c][/i][/p][/m]  
        [m1][p][i][c][com]сокр.[/i][/p] от [lang id=1033]it was; [p][i]уст.[/i][/p]; [p][i]поэт.[/lang][/com][/c][/i][/p][/m]
</pre>
  <p><i>После</i>)

  <pre>
заголовок
        [m1][c][com][p][i]сокр.[/i][/p] от [ref]them[/ref]; [p][i]разг.[/i][/p][/com][/c][/m]  
        [m1][c][com][p][i]гл.[/i][/p]; [p][i]сокр.[/i][/p]; [p][i]разг.[/i][/p][/com][/c][/m]  
        [m1][c][com][p][i]сокр.[/i][/p] от [lang id=1033]it was; [p][i]уст.[/i][/p]; [p][i]поэт.[/i][/p][/lang][/com][/c][/m]
</pre>
  <p><span><a class="mark" href="#op15" id="op15" name="op15">#</a></span> 15) <span class="comline">node nodereplacer.js (-base64 -i|-base64) input.txt output.txt</span><br>
  <b>а)</b> Внедрение картинок в HTML файл (<span class="comline">-base64 -i</span>).<br>
  Наличие словарной структуры у входного файла не обязательно.<br>
  Картинки должны находиться в папке "res", а папка "res" в одной папке с входным файлом.<br>
  Атрибуты src тегов IMG во входном файле должны содержать только имена файлов.

  <p>Пример 1:

  <pre>
&lt;img src="file.jpg"&gt; - правильно.
&lt;img src="IMAGES/file.jpg"&gt; - неправильно, недопустимо.
</pre>
  <p>Пример 2:

  <p><i>До</i>)

  <pre>
&lt;img src="file.jpg"&gt;
</pre>
  <p><i>После</i>)

  <pre>
&lt;img src="data:image/png;base64,...картинка в кодировке base64..."&gt;
</pre>
  <p>Информация о ненайденных картинках пишется в файл <span class="comline">error.log</span>

  <p><b>б)</b> Конвертирование одной картинки (<span class="comline">-base64</span>).

  <p>Пример:

  <p>Командная строка:<br>
  <i>node nodereplacer.js -base64 input.png output.txt</i>

  <p>Результат (output.txt):

  <pre>
&lt;img src="data:image/png;base64,iVBORw0KGg..." /&gt;

&lt;style&gt;
div.image {
background-image:url(data:image/png;base64,iVBORw0KGg...);
background-size: auto;
background-repeat: no-repeat;
width:100%;
height:100%;

}
&lt;/style&gt;

&lt;div class=image title="input.png"&gt;&lt;/div&gt;

</pre>
  <p><span><a class="mark" href="#op16" id="op16" name="op16">#</a></span> 16) <span class="comline">node nodereplacer.js -rb -(dsl1|dsl2|dslm1|dslm2|gls|glsm) input.txt output.txt</span><br>
  Раскрытие круглых скобок в заголовках словарных исходников.<br>
  Входной файл должен иметь словарную структуру.

  <p><b>-dsl1</b> и <b>-dsl2</b> - <i>для обработки словарей в формате DSL</i><a href="#dic"><sup>1</sup></a>

  <p><i>Разница между -dsl1 и -dsl2 будет показана ниже.</i>
  

  <p><b>-dslm1</b> и <b>-dslm2</b> - <i>то же самое, отличие только в том, что созданные при раскрытии круглых скобок заголовки будут маркироваться с помощью метки $$$.</i>

  <p><b>-gls</b> - <i>для обработки словарей в формате GLS</i> <a href="#gls"><sup>2</sup></a>

  <p><b>-glsm</b> - <i>маркировка</i>

  <p>DSL

  <p>Пример:

  <p>Командная строка:<br>
  <i>node nodereplacer.js <b>-rb -dsl1</b> input.txt output.txt</i>

  <p><i>До</i>)

  <pre>
(за)кончить(ся)
        перевод
кошка(ми)
собака\(ми\)
        перевод
кот{(}ы{)}
        перевод
свинья{(ми)}
        перевод
свинья\{(ми)\}
        перевод
овца{{(ми)}}
        перевод
</pre>
  <p><i>После</i>)

  <pre>
кончиться
закончить
закончиться
кончить
        перевод
кошками
кошка
        перевод
собака\(ми\)
        перевод
кот{(}ы{)}
        перевод
свинья{(ми)}
        перевод
свинья\{ми\}
свинья\{\}
        перевод
овца{{(ми)}}
        перевод
</pre>
  <p><b>Пояснение к примеру:</b>
  

  <ul>
    <li>Экранированные круглые скобки игнорируются.</li>

    <li>Скрипт умеет работать с заголовками сложенными в стопку.</li>

    <li>Скрипт не раскрывает круглые скобки если они находятся между двойными или одинарными неэкранированными фигурными скобками.</li>
  </ul>

  <p>РАЗЛИЧИЕ МЕЖДУ -dsl1 и -dsl2

  <p>Пример:

  <p>Командная строка:<br>
  <i>node nodereplacer.js <b>-rb -dsl2</b> input.txt output.txt</i>

  <p>До)

  <pre>(за)кончить(ся)
        перевод
</pre>
  <p>После -dsl1)

  <pre>кончиться
закончить
закончиться
кончить
        перевод 
</pre>
  <p>После -dsl2)

  <pre>{(за)}кончить{(}ся{)}
        перевод
{(}за{)}кончить{(ся)}
        перевод
{(}за{)}кончить{(}ся{)}
        перевод
{(за)}кончить{(ся)}
        перевод
</pre>
  <p>GLS

  <p>Пример:

  <p>Командная строка:<br>
  <i>node nodereplacer.js <b>-rb -gls</b> input.txt output.txt</i>

  <p><i>До</i>)

  <pre>
### Glossary title: Имя словаря
### Author: Имя автора
### Description: описание
### Source language: Russian
### Target language: Russian
### Glossary section:

кот|кот(ами)|кот(ами)
перевод

кошка\(ми\)
перевод

собака(ми)
перевод

(за)кончить(ся)
перевод
</pre>
  <p><i>После</i>)

  <pre>
### Glossary title: Имя словаря
### Author: Имя автора
### Description: описание
### Source language: Russian
### Target language: Russian
### Glossary section:

кот|котами
перевод

кошка\(ми\)
перевод

собака|собаками
перевод

кончить|кончиться|закончить|закончиться
перевод
</pre>
  <p><b>Пояснение к примеру:</b>
  

  <ul>
    <li>Экранированные круглые скобки игнорируются.</li>

    <li>Дубликаты из списка заголовков удаляются.<br>
    При этом сохраняются заголовки, которые находятся в начале строки.<br>
    Пример: до) кот|котами|кот =&gt; после) кот|котами (а не котами|кот)</li>
  </ul>

  <p><span><a class="mark" href="#op17" id="op17" name="op17">#</a></span> 17) <span class="comline">node nodereplacer.js -t input.txt output.txt</span><br>
  Получение списка HTML тэгов.<br>
  Наличие словарной структуры у входного файла не обязательно.

  <p><span><a class="mark" href="#op18" id="op18" name="op18">#</a></span> 18) <span class="comline">node nodereplacer.js (-chkdsl|-chkdsl -t) input.txt output.txt</span><br>
  Выявление ошибок в словарях в формате DSL.<br>
  Входной файл должен иметь словарную структуру.<br>
  <a href="chkdsl.htm">Подробнее на отдельной странице</a>.

  <p><span><a class="mark" href="#op19" id="op19" name="op19">#</a></span> 19) <span class="comline">node nodereplacer.js -mgls input.txt output.txt</span><br>
  Объединение статей в словарях в формате GLS.<br>
  Входной файл должен быть в формате GLS<a href="#gls"><sup>2</sup></a>.

  <p>Пример:

  <p><i>До</i>)

  <pre>
пёс|собака
тело1

барбос
тело1

пёс|собака
тело2

барбос|тузик
тело1

барбос|пёс
тело2

пёс|собака
тело2

барбос|тузик
тело1
</pre>
  <p><i>После</i>)

  <pre>
пёс|собака|барбос|тузик
тело1

пёс|собака|барбос
тело2
</pre>

  <hr />

  <p>Аварийная остановка - Ctrl+C

  <hr />

  <p><span><a class="mark" href="#add" id="add" name="add">#</a></span> <span class="subs">Дополнение</span>:

  <p>На <span class="func">Windows</span> скрипт будет удобнее запускать если создать batch файл (rep.bat) с таким содержанием:

  <pre>
@ECHO OFF
if "%1" == "-h" (
        start firefox.exe C:\U\nodereplacer\help\index.htm 
) ELSE (
        node --harmony_regexp_lookbehind C:\U\nodereplacer\nodereplacer.js %*
        pause
)
</pre>
  <p>Этот файл нужно поместить в папку C:\Windows\System32\ и отредактировать пути если нужно.

  <p>Можно также заменить "<span class="comline">firefox.exe</span>" на другой браузер.

  <p>После этого скрипт можно будет запускать из любого места используя такую командную строку:<br>
  <span class="comline">rep -rt list input.txt output.txt</span>

  <p>Вызов справки: <span class="comline">rep -h</span>

  <p>Вариант для <span class="func">Linux</span>:

  <pre>
function nodereplacer()
{
clear
if [[ $# -eq 1 ]] &amp;&amp; [[ "$1" == "-h" ]]; then
        (firefox полный_путь/help/index.htm &gt;/dev/null 2&gt;&amp;1 &amp;)
else
        node --harmony_regexp_lookbehind --harmony_regexp_property полный_путь/nodereplacer.js "$@"
        echo ''
        echo "$(tput sgr 0)$(tput setaf 3)Press Enter to return$(tput sgr 0)"
        read input
fi      
}


alias rep=nodereplacer
</pre>
  <p>Вышеприведенный код нужно добавить в <span class="comline">.bashrc</span> файл.

  <hr />

  <p><span class="subs">Сноски</span>
  

  <p><span><a class="mark" href="#dic" id="dic" name="dic">#</a></span> <sup>1</sup> Файл имеющий словарную структуру (формат DSL) - <span class='c7'>это файл в котором заглавные слова пишутся с первой позиции новой строки, а начиная со следующей строки после заголовка записывается тело статьи, причем каждая строка в нем должна отступать от первой позиции хотя бы на один пробел или табуляцию. Тело статьи простирается до заголовка следующей статьи (признаком его является символ в первой позиции, отличный от пробела или табуляции) или до конца файла. Между телом одной и заголовком следующей статьи для удобства чтения исходного текста могут быть вставлены одна или несколько пустых строк.</span>

  <p><span><a class="mark" href="#gls" id="gls" name="gls">#</a></span> <sup>2</sup> Формат GLS (Babylon glossary file):

  <pre>
 ПРИМЕР СЛОВАРЯ В ФОРМАТЕ GLS 
 
 ### Glossary title: Имя словаря
 ### Author: Имя автора
 ### Description: описание
 ### Source language: English
 ### Target language: English
 ### Glossary section:

 cat
 Definition

 dog
 Definition

 --------------------
 
 ОПИСАНИЕ ФОРМАТА GLS

 [блок директив]
 [пустая строка]
 заголовок
 определение
 [пустая строка]
 заголовок1|заголовок2|заголовок3...
 определение
 [пустая строка]
 ...

 1. В начале файла пустая строка факультативна.
 2. Блок директив факультативен.
 3. Блок директив и следующие за ним статьи должны быть разделены хотя бы одной пустой строкой.
 4. Статья - это две следующих одна за другой непустые строки, которые не являются частью блока директив. 
    И которые отделены от предшествующей и следующей непустой строки хотя бы одной пустой строкой.
 5. Меньше или больше двух непустых строк между пустыми ошибочно.
 6. Пустые строки в конце файла факультативны.  

</pre>

  <hr />
</body>
</html>
